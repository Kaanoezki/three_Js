<!DOCTYPE html>
<html lang="en">
<head>
    <!--meta data-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--css-->
    <link rel="stylesheet" type="text/css" href="styles.css">
    <link rel="stylesheet" type="text/css" href="navbar.css">
    
    <title>Bewerbung</title>
    <!--fonts-->
    <link href="shttps://fonts.googleapis.com/css2?family=Open+Sans&display=wap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=League+Spartan&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Titillium+Web&display=swap" rel="stylesheet">
</head>

<body>
    <!-- testcontainer -->
    <!-- <div id="scene-container2">scene 2 container</div> -->
    <div id="threejs-container" onclick="onClick(event)"></div>
    <div id="layer1" class="layer">main</div>
    <div id="uneven" class="layer ">Inhalt für Layer 1</div>
    
    <div id="even" class="layer trapezoid ">
        <div class="invisble a">Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam</div>   
         <div  class="invisble b">Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam</div>
         <div class="invisble c">Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam</div>   
         <div  class="invisble d">Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam</div>
         <div  class="text-container e">But I must explain to you how all this mistaken idea of denouncing pleasure and praising pain was born and I will give you a complete account of the system, and expound the actual teachings of the great explorer of the truth, the master-builder of human happiness. No one rejects, dislikes, or avoids pleasure itself, because it is pleasure, but because those who do not know how to pursue pleasure rationally encounter consequences that are extremely painful. Nor again is there anyone who loves or pursues or desires to obtain pain of itself, because it is pain, but because occasionally circumstances occur in which toil and pain can procure him some great pleasure. To take a trivial example, which of us ever undertakes laborious physical exercise, except to obtain some advantage from it? But who has any right to find fault with a man who chooses to enjoy a pleasure that has no annoying consequences, or one who avoids a pain that produces no resultant pleasure?</div>
         <div  class="invisble f">Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam</div>
         <div  class="invisble g">Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam</div>
         <div  class="invisble h">Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam</div>
         <div  class="invisble i">Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam</div>
        </div>
                        
    <div id="uneven" class="layer aa ">Inhalt für Layer 3</div>
    <div id="even" class="layer trapezoid-inverse">
        <div class="invisble a">Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam</div>   
         <div  class="invisble b">Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam</div>
         <div class="invisble c">Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam</div>   
         <div  class="invisble d">Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam</div>
         <div  class="text-container e">But I must explain to you how all this mistaken idea of denouncing pleasure and praising pain was born and I will give you a complete account of the system, and expound the actual teachings of the great explorer of the truth, the master-builder of human happiness. No one rejects, dislikes, or avoids pleasure itself, because it is pleasure, but because those who do not know how to pursue pleasure rationally encounter consequences that are extremely painful. Nor again is there anyone who loves or pursues or desires to obtain pain of itself, because it is pain, but because occasionally circumstances occur in which toil and pain can procure him some great pleasure. To take a trivial example, which of us ever undertakes laborious physical exercise, except to obtain some advantage from it? But who has any right to find fault with a man who chooses to enjoy a pleasure that has no annoying consequences, or one who avoids a pain that produces no resultant pleasure?</div>
         <div  class="invisble f">Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam</div>
         <div  class="invisble g">Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam</div>
         <div  class="invisble h">Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam</div>
         <div  class="invisble i">Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam</div>
        </div>
   
    <!--navbar-->
    <nav>
        <nav class="textresizer">
            <ul class="navbar container">
                <li class="a">Start</li>
                <li class="b">Bewerbung</li>
                <li class="c">lebenslauf</li>
                <li class="d">letztes Projekt</li>
                <a class="v blink">Navigation</a>
            </ul>
        </nav>
    </nav>
   
    <!--external sources-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/three.min.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>

    <!-- <script src="https://unpkg.com/three@0.126.0/examples/js/postprocessing/EffectComposer.js"></script> -->
    <!--outliner script-->

    <!--internal scripts-->
    <script src="sceneObjects.js"></script>
    <script src="logo.js"></script>
    <script type="module">
        // scene 
        var scene, camera, renderer;
        var scene1, camera2, renderer2;
    </script>

    <script>
        var mouseY = 0, mouseX = 0 ,targetX = 0, targetY = 0;
        var  controls, gui;
       //init scene
        function init() {
            //scene
            scene = new THREE.Scene();
            if (!scene) {
                console.error('Die Szene wurde nicht initialisiert!');
                return;
            }
            //camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 5);
            camera.lookAt(0, -0, 0);

            renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setClearColor(0x00000000, 0);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById("threejs-container").appendChild(renderer.domElement);
            animate();
            isoRotation();
        }
                const sceneInitializedEvent = new Event('sceneInitialized');
                window.dispatchEvent(sceneInitializedEvent);

    init();
        // Funktion, um zu überprüfen, ob ein Element im Viewport ist
        function isElementInViewport(el) {
            var rect = el.getBoundingClientRect();
            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }
        gui = new dat.GUI();
        const zoomSettings = {
            zoom: 4
        };
        const rotationSettings = {
        rotationY: 2.8,
        rotationX: 1,
  
        };
        gui.add(zoomSettings, 'zoom', 0.1, 20).onChange(zoomCamera);
        const targetPosition = new THREE.Vector3(0, 0, 0);
        function zoomCamera() {
        const newZoom = zoomSettings.zoom;
        const initialDistance = 50; 
        const newDistance = initialDistance / newZoom;
        const direction = new THREE.Vector3().subVectors(camera.position, targetPosition).normalize();
        // Berechne die neue Position der Kamera
        const newPosition = targetPosition.clone().add(direction.multiplyScalar(newDistance));

        camera.position.copy(newPosition);
        camera.lookAt(targetPosition);
        camera.updateProjectionMatrix();
        
    }
gui.add(rotationSettings, 'rotationY', 0, Math.PI * 2).onChange(updateRotation);
gui.add(rotationSettings, 'rotationX', 0, Math.PI * 2).onChange(updateRotation);

function updateRotation() {
    isoRotation(rotationSettings.rotationY, rotationSettings.rotationX);
}

function isoRotation(rotationY, rotationX) {
    const target = new THREE.Vector3(0, 0, 0);
    const distance = 10; 
    const phi = rotationX !== undefined ? rotationX : Math.PI / 4;
    const theta = rotationY !== undefined ? rotationY : Math.PI / 2.5;
   
    const x = distance * Math.sin(phi) * Math.cos(theta);
    const y = distance * Math.cos(phi);
    const z = distance * Math.sin(phi) * Math.sin(theta);

    camera.position.set(x, y, z);
    camera.lookAt(target);
}
updateRotation();
        function isElementInViewport(el) {
        var rect = el.getBoundingClientRect();
        
        return (
            rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
            rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }

        function isElementInViewport(el) {
        var rect = el.getBoundingClientRect();
        return (
            rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
            rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }

        document.addEventListener('wheel', function (event) {
            var layer1 = document.getElementById('layer1');
            if (!isElementInViewport(layer1)) {
                event.preventDefault();
                zoomCamera(event.deltaY * -0.05);
            }
        });

        function isElementInViewport(el) {
            var rect = el.getBoundingClientRect();

            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }
    function light() {
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.rotation.x = Math.PI / 2; 
        directionalLight.position.set(1,1,1);
        
        scene.add(directionalLight);
        const lightHelper = new THREE.DirectionalLightHelper(directionalLight, 1);
        scene.add(lightHelper);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight2.position.set(1, 5, 0).normalize();
        scene.add(directionalLight);
        const lightHelper2 = new THREE.DirectionalLightHelper(directionalLight, 1);
        scene.add(lightHelper);

        const ambientLight = new THREE.AmbientLight(0xffffff); // Farbe und Intensität
        ambientLight.intensity = 1; // Hier die Intensität anpassen (zwischen 0 und 1)
        ambientLight.position.set(1, 5, 0);     
        scene.add(ambientLight);


        const spotLight = new THREE.SpotLight(0xffffff, 15);
        spotLight.angle = Math.PI / 60; // Öffnungswinkel des Strahls
        spotLight.penumbra = 1; // Weiche Kante des Strahls
        spotLight.decay = 5; // Abnahme des Lichts mit dem Abstand
        spotLight.distance = 200; // Maximale Reichweite des Strahls
        camera.add(spotLight);

        const ambientLightSpot = new THREE.AmbientLight(0xffffff); // Farbe und Intensität
        ambientLightSpot.intensity = 4; // Hier die Intensität anpassen (zwischen 0 und 1)
        camera.add(ambientLightSpot);

    function animateLightFollowCamera() {
        requestAnimationFrame(animateLightFollowCamera);
        ambientLight.position.copy(camera.position);
        ambientLightSpot.position.copy(camera.position);

        // Aktualisiere Spot-Lichtposition und Zielposition auf den Ursprung
        const target = new THREE.Vector3(0, 3, 0);
        spotLight.position.copy(camera.position);
        spotLight.target.position.copy(target);
    }

    animateLightFollowCamera();
}
        function loadBlueprint() {
            const loader = new THREE.GLTFLoader();
            loader.load('../assets/objects/turntable.glb', (gltf) => {
                // const setPosition = new THREE.Vector3(-0.5625 , -0.2375 , 0);
                const setPosition = new THREE.Vector3(1 , 1, 0);
                const setScale = new THREE.Vector3(1.2, 1, 1.2);

                gltf.scene.traverse((child) => {
            if (child.isMesh) {
                // Erstellen Sie ein MeshStandardMaterial ohne Texturen
                const material = new THREE.MeshStandardMaterial({
                    color: 0x00FFFF,  // Farbe des Materials
                    metalness: 0.1,     // Setzen Sie die Metallheit auf 1 für ein metallisches Material
                    roughness: 0.1,   // Optional: Passen Sie die Rauheit an
                    flatShading: true,
                });

                child.material = material;
            }
        });

                const blueprint = new objectSpwn(gltf.scene, setPosition, setScale);
            });
        }
      
        
        // css update/ lerp effect
        document.addEventListener('DOMContentLoaded', function () {
        document.addEventListener('mousemove', (event) => {
        mouseX = event.clientX;
        mouseY = event.clientY;
            updateTextContent();
        });
    });
        //lerp function
        function animateCamera() {
            targetX = (mouseX / window.innerWidth) * 1 - 1;
            targetY = -(mouseY / window.innerHeight) * 1 + 1;
            const lerpFactor = 0.1; 
            camera.position.x = THREE.MathUtils.lerp(camera.position.x, targetX * 5, lerpFactor);
            camera.position.y = THREE.MathUtils.lerp(camera.position.y, targetY * 5, lerpFactor);
            camera.lookAt(scene.position);
        }
        //resizer window für die scene
        function handleWindowResize() {
        // Aktualisiere die Kamera-Aspektverhältnis
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        // Aktualisiere die Renderer-Größe
        renderer.setSize(window.innerWidth, window.innerHeight);
        }
        // Listener für Änderungen der Fenstergröße hinzufügen
        window.addEventListener('resize', handleWindowResize, false);

        function animate() {
            animateCamera();//lerp 
            
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            if (!scene) {
            console.error('Die Szene wurde nicht initialisiert!');
            return;
            }
        }

        function windowResize() {
            let currentWidth = window.innerWidth;
            let currentHeight = window.innerHeight;
            const threshold = 10;

            if (Math.abs(currentWidth - window.innerWidth) > threshold) {
                updateObjPosition();
            }
        }
        window.addEventListener('resize', windowResize);

        // mouseclick effect
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        // raycast obj is clicked
        function onObjectClick(event, gltfScene) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(gltfScene.children, true);
            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;

                if (clickedObject.isMesh) {
                    // Direkt die Farbe ändern
                    if (clickedObject.isMesh && clickedObject === 'laptop') {
                        clickedObject.material.color.set(0x00ff00);  // Setze die Farbe auf Grün
                        console.log('Mesh exists');
                    }
                }
                console.log('clickedObject.name:', clickedObject.name);
                console.log('layer1 background color:', document.getElementById('layer1').style.backgroundColor);
            // Ändere den Hintergrund nur, wenn das geklickte Objekt den Namen 'enter name' hat
            if (clickedObject.name === 'room' ) {
                document.getElementById('layer1').style.backgroundColor = 'green';
                document.getElementById('layer2').style.display = 'none';
                
                    }
                }
            }   
        function onClick(event) {
            onObjectClick(event, roomObj.initObj);
        }
        document.getElementById('threejs-container').addEventListener('click', onClick, false);
        windowResize();
        initObjects();

        //hover 
        document.addEventListener('DOMContentLoaded', function () {
    const textContainerE = document.querySelector('.text-container.e');

    textContainerE.addEventListener('mouseenter', function () {
        textContainerE.style.fontFamily = 'sans-serif';
        textContainerE.style.fontSize = '50px';
        textContainerE.style.color = 'red';
    });

    textContainerE.addEventListener('mouseleave', function () {
        textContainerE.style.fontFamily = '';
        textContainerE.style.fontSize = '1.5vw';
        textContainerE.style.color = '';
    });
});


        
    </script>
        <script>//ergänzung für den css textinhalt änderung(innerhtml)
            // Funktion zum Aktualisieren des Textinhalts basierend auf der Bildschirmbreite
       function updateTextContent() {
           var screenWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
           var layer1 = document.getElementById('layer1');
       
           if (screenWidth <= 600) {
               (layer1).innerText   = 'If you dont use a smaller Device, please change the window-size for a better experience !';
           } else {
               layer1.innerText = 'Inhalt für Layer 1';
           }
       }
       window.addEventListener('resize', function () {
           updateTextContent();
       });
       // Event-Listener für das 'DOMContentLoaded'-Event, um den Textinhalt beim Laden der Seite zu initialisieren
       window.addEventListener('DOMContentLoaded', function () {
           updateTextContent();
       });

    </script>
    
</body>
</html>