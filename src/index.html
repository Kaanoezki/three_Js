<!DOCTYPE html>
<html lang="en">
<head>
    <!--meta data-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--css-->
    <link rel="stylesheet" type="text/css" href="styles.css">
    <link rel="stylesheet" type="text/css" href="navbar.css">
    
    <title>Bewerbung</title>
    <!--fonts-->
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=League+Spartan&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Titillium+Web&display=swap" rel="stylesheet">
</head>
<body>
  
   
    <div id="layer1" class="layer">Inhalt für Layer 1</div>
    <div id="layer2" class="layer outliner">Inhalt für Layer 2</div>
    <div id="threejs-container" class="suzann-container" onclick="onClick(event)"></div>
    <!--navbar-->
    <nav>
        <ul class="navbar container">
            <li class="a">Start</li>
            <li class="b">Bewerbung</li>
            <li class="c">lebenslauf</li>
            <li class="d">letztes Projekt</li>
            <a class="v blink">Navigation</a>
        </ul>
    </nav>
   
    <!--external sources-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/three.min.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/postprocessing/EffectComposer.js"></script>
    <!--outliner script-->

    <!--internal scripts-->
    <script src="sceneObjects.js"></script>
    <script src="mouseEvents.js"></script>
    <script type="module">
        // scene 
        var scene, camera, renderer;
    </script>

    <script>
        var mouseY = 0, mouseX = 0 ,targetX = 0, targetY = 0;
        var suzannObj, controls, gui;
       //init scene
        function init() {
            //scene
            scene = new THREE.Scene();
            if (!scene) {
                console.error('Die Szene wurde nicht initialisiert!');
                return;
            }
            //camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 5);
            camera.lookAt(0, -0, 0);

            renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setClearColor(0x00000000, 0);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById("threejs-container").appendChild(renderer.domElement);
            animate();
            isoRotation();
        }
                const sceneInitializedEvent = new Event('sceneInitialized');
                window.dispatchEvent(sceneInitializedEvent);

           
        init();

        

        // Funktion, um zu überprüfen, ob ein Element im Viewport ist
        function isElementInViewport(el) {
            var rect = el.getBoundingClientRect();
            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }
        gui = new dat.GUI();
        const zoomSettings = {
            zoom: 4
        };
        const rotationSettings = {
        rotationY: 2.5,
        rotationX: 1,
  
        };
        gui.add(zoomSettings, 'zoom', 0.1, 20).onChange(zoomCamera);
        const targetPosition = new THREE.Vector3(0, 0, 0);
        function zoomCamera() {
        const newZoom = zoomSettings.zoom;
        const initialDistance = 50; 
        const newDistance = initialDistance / newZoom;
        const direction = new THREE.Vector3().subVectors(camera.position, targetPosition).normalize();
        // Berechne die neue Position der Kamera
        const newPosition = targetPosition.clone().add(direction.multiplyScalar(newDistance));

        camera.position.copy(newPosition);
        camera.lookAt(targetPosition);
        camera.updateProjectionMatrix();
        
    }

gui.add(rotationSettings, 'rotationY', 0, Math.PI * 2).onChange(updateRotation);
gui.add(rotationSettings, 'rotationX', 0, Math.PI * 2).onChange(updateRotation);

function updateRotation() {
    isoRotation(rotationSettings.rotationY, rotationSettings.rotationX);
}

function isoRotation(rotationY, rotationX) {
    const target = new THREE.Vector3(0, 0, 0);
    const distance = 10; 
    const phi = rotationX !== undefined ? rotationX : Math.PI / 4;
    const theta = rotationY !== undefined ? rotationY : Math.PI / 2.5;
   
    const x = distance * Math.sin(phi) * Math.cos(theta);
    const y = distance * Math.cos(phi);
    const z = distance * Math.sin(phi) * Math.sin(theta);

    camera.position.set(x, y, z);
    camera.lookAt(target);
}
updateRotation();
        function isElementInViewport(el) {
        var rect = el.getBoundingClientRect();
        
        return (
            rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
            rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }

        function isElementInViewport(el) {
        var rect = el.getBoundingClientRect();
        return (
            rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
            rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }

        document.addEventListener('wheel', function (event) {
            var layer2 = document.getElementById('layer2');
            if (!isElementInViewport(layer2)) {
                event.preventDefault();
                zoomCamera(event.deltaY * -0.05);
            }
        });

        function isElementInViewport(el) {
            var rect = el.getBoundingClientRect();

            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }

        function light() {
    // Annahme: Directional Light wurde bereits erstellt und zur Szene hinzugefügt
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(1, 1, 0).normalize();
    scene.add(directionalLight);

    // DirectionalLightHelper zeigt die Richtung des Lichts an
    const lightHelper = new THREE.DirectionalLightHelper(directionalLight, 1);
    scene.add(lightHelper);

    let isDragging = false;
    const lerpFactor = 0.05; // Anpassbare Lerp-Faktor für die Sanftheit der Bewegung

    // Zielposition für die Lerpbewegung
    const targetPosition = new THREE.Vector3();

    // Funktion zum Starten des Dragging
    function startDragging(event) {
        isDragging = true;
    }

    // Funktion zum Stoppen des Dragging
    function stopDragging() {
        isDragging = false;
    }

    // Funktion zum Bewegen des Lichts basierend auf Mausbewegungen
    function moveLight(event) {
        if (isDragging) {
            const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

            const mousePosition = new THREE.Vector3(mouseX, mouseY, 0.5);
            mousePosition.unproject(camera);

            const raycaster = new THREE.Raycaster(camera.position, mousePosition.sub(camera.position).normalize());
            const intersection = raycaster.intersectObject(scene, true);

            if (intersection.length > 0) {
                targetPosition.copy(intersection[0].point);
            }
        }
    }

    // Füge Event Listener für das Starten und Stoppen des Dragging hinzu
    document.addEventListener('mousedown', startDragging);
    document.addEventListener('mouseup', stopDragging);

    // Füge Event Listener für das Bewegen des Lichts hinzu
    document.addEventListener('mousemove', moveLight);

    // Beispiel: Animiere das Licht mit Lerpbewegung
    function animateLightSwing() {
        // Lerpe die aktuelle Position zum Ziel
        directionalLight.position.lerp(targetPosition, lerpFactor);
        lightHelper.update(); // Aktualisiere den Helper
        requestAnimationFrame(animateLightSwing);
    }

    // Starte die Animation
    animateLightSwing();
}



           // test objekt, dont overthink (suzann is offmap)
        function loadBlueprint() {
            const loader = new THREE.GLTFLoader();
            loader.load('../assets/objects/turntable.glb', (gltf) => {
                // const setPosition = new THREE.Vector3(-0.5625 , -0.2375 , 0);
                const setPosition = new THREE.Vector3(1 , 1, 0);
                const setScale = new THREE.Vector3(1.2, 1, 1.2);

                gltf.scene.traverse((child) => {
            if (child.isMesh) {
                // Erstellen Sie ein MeshStandardMaterial ohne Texturen
                const material = new THREE.MeshStandardMaterial({
                    color: 0x00FFFF,  // Farbe des Materials
                    metalness: 0.1,     // Setzen Sie die Metallheit auf 1 für ein metallisches Material
                    roughness: 0.1,   // Optional: Passen Sie die Rauheit an
                    flatShading: true,
                });

                child.material = material;
            }
        });

                const blueprint = new objectSpwn(gltf.scene, setPosition, setScale);
            });
        }
        // test objekt, dont overthink (suzann is offmap)
        function loadSuzann() {
            const loader = new THREE.GLTFLoader();
            loader.load('../assets/suzann.gltf', (gltf) => {
                const setPosition = new THREE.Vector3(1000, 0, 0);
                const setScale = new THREE.Vector3(1, 1, 1);
                gltf.scene.name = 'suzann';

                gltf.scene.traverse((child) => {
                    if (child.isMesh) {
                        let normalMap = new THREE.TextureLoader().load('../assets/materials/blueprint_normal.png');
                        normalMap.repeat.set(2, 2);
                        normalMap.wrapS = THREE.RepeatWrapping;
                        normalMap.wrapT = THREE.RepeatWrapping;
                        const normalScale = new THREE.Vector2(0.3, 0.001);
                        const material = new THREE.MeshStandardMaterial({
                            map: new THREE.TextureLoader().load('../assets/materials/blueprint_diffuse.png'),
                            normalMap: normalMap,
                            normalScale: normalScale,
                            side: THREE.DoubleSide
                        });
                        child.material = material;
                    }
                });

                suzannObj = new objectSpwn(gltf.scene, setPosition, setScale);
            });
        }
        // css update/ lerp effect
        document.addEventListener('DOMContentLoaded', function () {
            document.addEventListener('mousemove', (event) => {
        mouseX = event.clientX;
        mouseY = event.clientY;
            updateTextContent();
        });
    });
        //lerp function
        function animateCamera() {
        targetX = (mouseX / window.innerWidth) * 1 - 1;
        targetY = -(mouseY / window.innerHeight) * 1 + 1;
        const lerpFactor = 0.1; 
        camera.position.x = THREE.MathUtils.lerp(camera.position.x, targetX * 5, lerpFactor);
        camera.position.y = THREE.MathUtils.lerp(camera.position.y, targetY * 5, lerpFactor);
        camera.lookAt(scene.position);
        }
        function animate() {
            animateCamera();//lerp 
            
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            if (!scene) {
            console.error('Die Szene wurde nicht initialisiert!');
            return;
            }
        }

        function windowResize() {
            let currentWidth = window.innerWidth;
            let currentHeight = window.innerHeight;
            const threshold = 10;

            if (Math.abs(currentWidth - window.innerWidth) > threshold) {
                updateObjPosition();
            }
        }

        window.addEventListener('resize', windowResize);

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        function onObjectClick(event, gltfScene) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(gltfScene.children, true);

            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;

                if (clickedObject.isMesh) {
                    // Direkt die Farbe ändern
                    if (clickedObject.material) {
                        clickedObject.material.color.set(0x00ff00);  // Setze die Farbe auf Grün
                        console.log('Mesh exists');
                    }
                }
                console.log('clickedObject.name:', clickedObject.name);
                console.log('layer1 background color:', document.getElementById('layer1').style.backgroundColor);
               
            // Ändere den Hintergrund nur, wenn das geklickte Objekt den Namen 'suzann' hat
            if (clickedObject.name === 'suzann' ) {
                document.getElementById('layer1').style.backgroundColor = 'green';
                document.getElementById('layer2').style.display = 'none';
                
                    }
                }
            }

        function onClick(event) {
            onObjectClick(event, suzannObj.initObj);
        }

        document.getElementById('threejs-container').addEventListener('click', onClick, false);
        windowResize();
        initObjects();
        
        
    </script>
        <script>//ergänzung für den css textinhalt änderung(innerhtml)
            // Funktion zum Aktualisieren des Textinhalts basierend auf der Bildschirmbreite
       function updateTextContent() {
           var screenWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
           var layer1 = document.getElementById('layer1');
       
           if (screenWidth <= 600) {
               layer1.innerText = 'If you dont use a smaller Device, please change the window-size for a better experience !';
           } else {
               layer1.innerText = 'Inhalt für Layer 1';
           }
       }
       window.addEventListener('resize', function () {
           updateTextContent();
       });
       // Event-Listener für das 'DOMContentLoaded'-Event, um den Textinhalt beim Laden der Seite zu initialisieren
       window.addEventListener('DOMContentLoaded', function () {
           updateTextContent();
       });

    </script>
    
</body>
</html>