<!DOCTYPE html>
<html lang="en">
<head>
    <!--meta data-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--css-->
    <link rel="stylesheet" type="text/css" href="styles.css">
    <link rel="stylesheet" type="text/css" href="navbar.css">
    <title>Bewerbung</title>
    <!--fonts-->
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans&display=wap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=League+Spartan&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Titillium+Web&display=swap" rel="stylesheet">
    <!-- snap scroll not smooth yet! -->    
    <script>
    function disappearDiv() {
    var div = document.querySelector('.disappearing-div');
    div.classList.add('disappeared');
    }
    //scroll snapping
    document.addEventListener("DOMContentLoaded", function() {
    console.log("DOMContentLoaded event fired");
    const container = document.getElementById("container");
    const images = document.querySelectorAll(".img-container");
    let currentIndex = 0;
    // Eventlistener für das Mausrad hinzufügen
    container.addEventListener("wheel", function(event) {
        console.log("Mouse wheel event");
        // Berechne den Index des nächsten Bildes
        currentIndex = (currentIndex + (event.deltaY > 0 ? 1 : -1) + images.length) % images.length;
        // Scrolle zum ausgewählten Bild mit Smooth-Scrolling
        images[currentIndex].scrollIntoView({ behavior: 'smooth', block: 'start' });
        // Verhindere das Standard-Scrollverhalten, um Doppelscrollen zu vermeiden
        event.preventDefault();
    }, { passive: false });
    });
     </script>

     
</head>
<body>    
    <div id="overlay-container"class="disappearing-div" onclick="disappearDiv(this)">
        <div class=" text-container-2 ">
        Willkommen auf meiner persönlichen Portfolio-Seite! diese Seite wir wird noch bearbeitet. KLICK HIER um fortzufahren
         </div>
        </div>

        <!--sprechbubble zwischen overlay und three js scene-->
        <div id="overlay" onclick="closeOverlay()"></div>
        <div id="speechBubble">
            <p>Text in der Sprechblase</p>
        </div>
        


    <div id="container"><!--scroll snap-->
        <div id="threejs-container" class="img-container " onclick="onClick(event)"></div>
        <div id="layer1" ></div><!--layer1=three scene --> 
    <div class="layer  img3 scroll-section"></div>
        <div id="containerbox">
                <div class="img-container img2"></div>
                <div class=" text-container-1 headliner">
                But I must explain to you how all 
                this mistaken idea of denouncing pleasure and praising pain 
                was born and I will give you a complete account of the system,
                and expound the actual teachings of the great explorer of the
                But I must explain to you how all 
                this mistaken idea of denouncing pleasure and praising pain 
                was born and I will give you a complete account of the system,
                and expound the actual teachings of the great explorer of the  
            </div>
        </div>
        <div id="containerbox">
                <div class="img-container img2"></div>
                <div class=" text-container-1 headliner">
                But I must explain to you how all 
                this mistaken idea of denouncing pleasure and praising pain 
                was born and I will give you a complete account of the system,
            </div>
        </div>
        <div id="containerbox">
            <div class="img-container img2"></div>
            <div class=" text-container-1 headliner">
                But I must explain to you how all 
                this mistaken idea of denouncing pleasure and praising pain 
                was born and I will give you a complete account of the system,
                and expound the actual teachings of the great explorer of the 
                truth, the master-builder of human happiness. No one rejects, 
            </div>
          
        </div>
        <div class="parallax blur background1 ">
        </div>
        <div class="parallax blur background2 ">
        </div>
        <div class="parallax blur background3 ">
            </div>

    </div>
    <script>
        function scrollToSection(sectionId) {
            const section = document.getElementById(sectionId);
            window.scrollTo({
                top: section.offsetTop,
                behavior: 'smooth'
            });
        }
    </script>
    <!--navbar-->
    <nav>
        <nav class="textresizer">
            <ul class="navbar container">
                <li class="a"><a href="#threejs-container" onclick="scrollToSection('threejs-container')">Start</a></li>
                <li class="b"><a href="#layer1" onclick="scrollToSection('layer1')">about me</a></li>
                <li class="c"><a href="containerbox" onclick="scrollToSection('containerbox')">Praktische Erfahrung </a></li>
                <li class="d"><a href="#containerbox" onclick="scrollToSection('containerbox')">Section 3</a></li>
                <a class="v blink">Navigation</a> 

                <!-- <li class="a">Start</li>
                <li class="b">Bewerbung</li>
                <li class="c">lebenslauf</li>
                <li class="d">letztes Projekt</li>
                <a class="v blink">Navigation</a> -->
            </ul>
        </nav>
    </nav>
   
    <!--external sources-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/three.min.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <!-- <script src="https://unpkg.com/three@0.126.0/examples/js/postprocessing/EffectComposer.js"></script> -->
    <!--outliner script-->

    <!--internal scripts-->
    <script src="sceneObjects.js"></script>
    <script src="logo.js"></script>
    <script type="module">
        // scene 
        var scene, camera, renderer;
        // var scene1, camera2, renderer2;
    </script>

    <script>
        var mouseY = 0, mouseX = 0 ,targetX = 0, targetY = 0;
        var  controls, gui;
       //init scene
        function init() {
            //scene
            scene = new THREE.Scene();
            if (!scene) {
                console.error('Die Szene wurde nicht initialisiert!');
                return;
            }
            //camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 5,20);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setClearColor(0x00000000, 0);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById("threejs-container").appendChild(renderer.domElement);
            animate();
            isoRotation();
        }
                const sceneInitializedEvent = new Event('sceneInitialized');
                window.dispatchEvent(sceneInitializedEvent);

    init();
        // Funktion, um zu überprüfen, ob ein Element im Viewport ist
        function isElementInViewport(el) {
            var rect = el.getBoundingClientRect();
            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }
        gui = new dat.GUI({ autoPlace: false });
        //place gui in three js container 
        const guiContainer = document.createElement('div');
        guiContainer.id = 'gui-container';
        guiContainer.style.position = 'absolute';
        guiContainer.style.top = '50';
        guiContainer.style.right = '0';
        guiContainer.style.zIndex = 5000;
        guiContainer.appendChild(gui.domElement);
        document.getElementById('threejs-container').appendChild(guiContainer);
        const zoomSettings = {
            zoom: 1
        };
        const rotationSettings = {
        rotationY: 2.8,
        rotationX: 1,
        };
        gui.add(zoomSettings, 'zoom', 0.1, 20).onChange(zoomCamera);

        const targetPosition = new THREE.Vector3(0, 0, 0);
        function zoomCamera() {
        const newZoom = zoomSettings.zoom;
        const initialDistance = 100; 
        const newDistance = initialDistance / (newZoom * 2);
        const direction = new THREE.Vector3().subVectors(camera.position, targetPosition).normalize();
        // Berechne die neue Position der Kamera
        const newPosition = targetPosition.clone().add(direction.multiplyScalar(newDistance));

        camera.position.copy(newPosition);
        camera.lookAt(targetPosition);
        camera.updateProjectionMatrix();
         
    }
gui.add(rotationSettings, 'rotationY', 0, Math.PI * 2).onChange(updateRotation);
gui.add(rotationSettings, 'rotationX', 0, Math.PI * 2).onChange(updateRotation);

function updateRotation() {
    isoRotation(rotationSettings.rotationY, rotationSettings.rotationX);
}

function isoRotation(rotationY, rotationX) {
    const target = new THREE.Vector3(0, 0, 0);
    const distance = 20; // init focus hier ändern!
    const phi = rotationX !== undefined ? rotationX : Math.PI / 4;
    const theta = rotationY !== undefined ? rotationY : Math.PI / 2.5;
   
    const x = distance * Math.sin(phi) * Math.cos(theta);
    const y = distance * Math.cos(phi);
    const z = distance * Math.sin(phi) * Math.sin(theta);

    camera.position.set(x, y, z);
    camera.lookAt(target);
}
updateRotation();
        function isElementInViewport(el) {
        var rect = el.getBoundingClientRect();
        
        return (
            rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
            rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }

        function isElementInViewport(el) {
        var rect = el.getBoundingClientRect();
        return (
            rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
            rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }

        document.addEventListener('wheel', function (event) {
            var layer1 = document.getElementById('layer1');
            if (!isElementInViewport(layer1)) {
                event.preventDefault();
                // zoomCamera(event.deltaY * -0.05);
                
            }
        
        });
            
        function isElementInViewport(el) {
            var rect = el.getBoundingClientRect();

            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }
    function light() {
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.rotation.x = Math.PI / 2; 
        directionalLight.position.set(1,1,1);
        
        scene.add(directionalLight);
        const lightHelper = new THREE.DirectionalLightHelper(directionalLight, 1);
        scene.add(lightHelper);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight2.position.set(1, 5, 0).normalize();
        scene.add(directionalLight);
        const lightHelper2 = new THREE.DirectionalLightHelper(directionalLight, 1);
        scene.add(lightHelper);

        const ambientLight = new THREE.AmbientLight(0xffffff); // Farbe und Intensität
        ambientLight.intensity = 1; // Hier die Intensität anpassen (zwischen 0 und 1)
        ambientLight.position.set(1, 5, 0);     
        scene.add(ambientLight);


        const spotLight = new THREE.SpotLight(0xffffff, 15);
        spotLight.angle = Math.PI / 60; // Öffnungswinkel des Strahls
        spotLight.penumbra = 1; // Weiche Kante des Strahls
        spotLight.decay = 5; // Abnahme des Lichts mit dem Abstand
        spotLight.distance = 200; // Maximale Reichweite des Strahls
        camera.add(spotLight);

        const ambientLightSpot = new THREE.AmbientLight(0xffffff); // Farbe und Intensität
        ambientLightSpot.intensity = 1; // Hier die Intensität anpassen (zwischen 0 und 1)
        camera.add(ambientLightSpot);

    function animateLightFollowCamera() {
        requestAnimationFrame(animateLightFollowCamera);
        ambientLight.position.copy(camera.position);
        ambientLightSpot.position.copy(camera.position);

        // Spot-Lichtposition und Zielposition auf den Ursprung
        const target = new THREE.Vector3(0, 3, 0);
        spotLight.position.copy(camera.position);
        spotLight.target.position.copy(target);
    }

    animateLightFollowCamera();
}
        // css update/ lerp effect
        document.addEventListener('DOMContentLoaded', function () {
        document.addEventListener('mousemove', (event) => {
        mouseX = event.clientX;
        mouseY = event.clientY;
            updateTextContent();
        });
    });
        //lerp function
        function animateCamera() {
            targetX = (mouseX / window.innerWidth) * 1 - 1;
            targetY = -(mouseY / window.innerHeight) * 1 + 1;
            const lerpFactor = 0.1; 
            camera.position.x = THREE.MathUtils.lerp(camera.position.x, targetX * 5, lerpFactor);
            camera.position.y = THREE.MathUtils.lerp(camera.position.y, targetY * 5, lerpFactor);
            camera.lookAt(scene.position);
        }
        //resizer window für die scene
        function handleWindowResize() {
        // Aktualisiere die Kamera-Aspektverhältnis
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        // Aktualisiere die Renderer-Größe
        renderer.setSize(window.innerWidth, window.innerHeight);
        }
        // Listener für Änderungen der Fenstergröße hinzufügen
        window.addEventListener('resize', handleWindowResize, false);

        function animate() {
            animateCamera();//lerp 
            
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            if (!scene) {
            console.error('Die Szene wurde nicht initialisiert!');
            return;
            }
        }

        function windowResize() {
            let currentWidth = window.innerWidth;
            let currentHeight = window.innerHeight;
            const threshold = 10;

            if (Math.abs(currentWidth - window.innerWidth) > threshold) {
                updateObjPosition();
            }
        }
        window.addEventListener('resize', windowResize);

        // mouseclick effect
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onObjectClick(event, gltfScene) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(gltfScene.children, true);

            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                showHoveredWindow(hoveredObject);

                if (clickedObject.isMesh) {
                    clickedObject.material.color.set(0x00ff00);  // Setze die Farbe auf Grün
                    console.log('Mesh exists');
                }
            }
        }
  



                function onClick(event) {
                    onObjectClick(event, roomObj.initObj);
                }
                document.getElementById('threejs-container').addEventListener('click', onClick, false);
                windowResize();
                initObjects();

    


        
    </script>
        <script>//ergänzung für den css textinhalt änderung(innerhtml)
            // Funktion zum Aktualisieren des Textinhalts basierend auf der Bildschirmbreite
            function updateTextContent() {
    var screenWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
    var layer1 = document.getElementById('layer1');

    if (screenWidth <= 600) {
        layer1.innerText = 'If you dont use a smaller Device, please change the window-size for a better experience !';
        layer1.style.position = 'fixed';
        layer1.style.top = '0%';
        layer1.style.left = '50%';
        layer1.style.transform = 'translate(-50%, -50%)';
        layer1.style.zIndex = '10000'; 
  
     
    } else {
        layer1.innerText = '';
        layer1.style.position = '';
        layer1.style.top = '';
        layer1.style.left = '';
        layer1.style.transform = '';
        layer1.style.zIndex = ''; 
      
    }
}

    </script>
    
</body>
</html>